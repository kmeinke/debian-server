# Session Summary 2026-02-16

## Lynis Audit Runner Design

**Unresolved:**
- salt-ssh infrastructure (roster file, master config) not yet created — prerequisite for the runner
- Multi-target parallel execution deferred
- Custom Lynis profiles deferred
- Whether `salt/runners/` will be used later when a master daemon is introduced

Explored how to implement on-demand Lynis security audits across nodes. Discussed the purpose of the `salt/runners/` directory (master-side execution modules) and where an SSH-based audit tool fits in the project's evolution toward salt-ssh central management.

Researched Lynis capabilities: audit modes (`--cronjob`, `--quiet`, `--pentest`), targeted scanning (`--tests-from-category`), output files (`lynis-report.dat` key=value format, `lynis.log`), custom profiles, and exit codes.

Designed a 6-step audit workflow: connect via salt-ssh, install Lynis, run audit, fetch results, remove Lynis and artifacts, then analyze locally. Key architectural decision: **standalone Python script in `scripts/`** rather than a Salt runner module, because there is no master daemon and the workflow is imperative, not declarative. This matches the existing `scripts/test.sh` pattern.

Report storage design: `reports/lynis/<hostname>/<timestamp>/` with raw report, log, and parsed `summary.json` — gitignored like `secrets/`. Differential analysis uses set-based comparison on Lynis test IDs between runs, producing new/resolved warnings and suggestions plus hardening index delta. Plan written but not yet approved for implementation.

## Exim4 SMTP Credentials Management

**Unresolved:**
- No encryption of secrets at rest (SOPS/GPG deferred)
- Production credentials not yet populated in `secrets/passwd.client`

Moved SMTP credentials out of pillar into a static file (`secrets/passwd.client`) deployed via `file://` source. Previously `passwd.client` was a Jinja template rendered from `mail.smarthost_user` and `mail.smarthost_password` pillar values — now it's a plain file in the gitignored `secrets/` directory, mounted read-only into the Docker container at `/srv/secrets`.

Discussed encryption options: Salt's built-in GPG renderer (works with both masterless and salt-ssh, decrypts on the control side), and SOPS with age/PGP backends. Both decrypt on the master/control machine. Decided against implementing encryption for now — the simple secrets file approach is sufficient for the current stage.

Added a roadmap note in README about planned migration from masterless `salt-call --local` to `salt-ssh`. Committed as `8c0326b`.

## SOPS + age Encryption Setup

**Unresolved:**
- Git identity not configured in WSL (commits must use Windows terminal)
- Production deploy workflow for salt-ssh + SOPS not yet tested on real host

Set up SOPS with age as encryption backend for all project secrets. Generated two age key pairs (personal `kmeinke` and `master` server key). Created `.sops.yaml` with both public keys so either private key can decrypt. Encrypted SSH keys (as base64) and SMTP credentials into a single SOPS-managed file.

Initially stored secrets in `sops/` directory with `.sops.yaml` extension. Explored Salt's SOPS integration options — no official plugin exists. Tried the community `jwestfall69/saltstack-sops-renderer` but hit a fundamental problem: SOPS encrypts the `#!sops|yaml` shebang line, so Salt can't detect the renderer. Pivoted to a decrypt-before-apply pattern: encrypted files stored as `*.sls.enc`, decrypted to `*.sls` before salt-ssh runs, cleaned up automatically via `trap EXIT` / `atexit`.

Created `scripts/sops.py` helper with import (binary-to-base64), export (base64-to-binary), edit, and rotate commands. Added `--input-type=yaml --output-type=yaml` flags for `.sls` files since SOPS doesn't recognize the extension natively. Originally written as bash (`sops.sh`) but rewritten in Python at user's preference.

## salt-ssh Migration

**Unresolved:**
- End-to-end `test.py test` not yet verified (container build + salt-ssh highstate)
- SSH host key management for production targets

Major architecture change from masterless `salt-call --local` (Salt runs inside Docker container) to `salt-ssh` (WSL is control machine, container is dumb SSH target). This simplifies SOPS integration since pillar rendering happens on the control side where age keys live.

Dockerfile rewritten: removed salt-minion/salt repo, added openssh-server + python3. Admin user bootstrapped with SSH public key baked in (chicken-and-egg: need SSH access before salt-ssh can manage the user). Docker-compose simplified: removed state/pillar/secrets volume mounts, added port 2222 mapping.

Created `salt/master` (salt-ssh config with file_roots, pillar_roots, roster path) and `salt/roster` (target definition). Initially used `/tmp/salt` for salt-ssh runtime files (logs, cache) to avoid permission issues with `/var/log/salt/`, later moved to project-local `.salt/` directory.

Secrets integrated as pillar: `salt/pillar/secrets/server.sls.enc` decrypted on-the-fly, referenced via `contents_pillar` in states. `test.py` handles decrypt/cleanup lifecycle.
